[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 powerjoin authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Antoine Fabri. Author, maintainer. Hadley Wickham. Contributor.            aut/cre dplyr Romain François. Contributor.            aut dplyr David Robinson. Contributor.           aut fuzzyjoin RStudio. Copyright holder, funder.           cph/fnd dplyr","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fabri (2024). powerjoin: Extensions 'dplyr' 'fuzzyjoin' Join Functions. R package version 0.1.0, https://github.com/moodymudskipper/powerjoin.","code":"@Manual{,   title = {powerjoin: Extensions of 'dplyr' and 'fuzzyjoin' Join Functions},   author = {Antoine Fabri},   year = {2024},   note = {R package version 0.1.0},   url = {https://github.com/moodymudskipper/powerjoin}, }"},{"path":"/index.html","id":"powerjoin-","dir":"","previous_headings":"","what":"Extensions of dplyr and fuzzyjoin Join Functions","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"{powerjoin} extends {dplyr}’s join functions. Make joins safer check argument check_specs()function Deal conflicting column names combining, coalescing etc using conflict argument Preprocess input, instance select columns join without repeat key columns selection painless fuzzy joins thanks generalized argument accepting formulas Fill unmatched values using fill argument Operate recursive joins providing lists data frames x y Keep drop key columns flexibility thanks enhanced keepargument","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"Install CRAN version : development version :","code":"install.packages(\"powerjoin\") remotes::install_github(\"moodymudskipper/powerjoin\")"},{"path":"/index.html","id":"now-lets-match-penguins","dir":"","previous_headings":"","what":"Now let’s match penguins","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"","code":"library(powerjoin) library(tidyverse)  # toy dataset built from Allison Horst's {palmerpenguins} package and  # Hadley Wickham's {babynames}  male_penguins <- tribble(      ~name,    ~species,     ~island, ~flipper_length_mm, ~body_mass_g,  \"Giordan\",    \"Gentoo\",    \"Biscoe\",               222L,        5250L,   \"Lynden\",    \"Adelie\", \"Torgersen\",               190L,        3900L,   \"Reiner\",    \"Adelie\",     \"Dream\",               185L,        3650L )  female_penguins <- tribble(      ~name,    ~species,  ~island, ~flipper_length_mm, ~body_mass_g,   \"Alonda\",    \"Gentoo\", \"Biscoe\",               211,        4500L,      \"Ola\",    \"Adelie\",  \"Dream\",               190,        3600L, \"Mishayla\",    \"Gentoo\", \"Biscoe\",               215,        4750L, )"},{"path":"/index.html","id":"safer-joins","dir":"","previous_headings":"","what":"Safer joins","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"check argument receives object created check_specs() function, provides ways handle specific input properties, arguments can : \"ignore\" : stay silent (default except implicit_keys) \"inform\" \"warn\" \"abort\" can print defaults : default works like {dplyr}, informing case implicit keys, checks : can silence implicit key detection check unique keys right table column_conflict argument guarantees won’t columns renamed without knowing, might need time, setup development production specs common joins: save typing :","code":"check_specs() #> # powerjoin check specifications #> ℹ implicit_keys #> → column_conflict #> → duplicate_keys_left #> → duplicate_keys_right #> → unmatched_keys_left #> → unmatched_keys_right #> → missing_key_combination_left #> → missing_key_combination_right #> → inconsistent_factor_levels #> → inconsistent_type #> → grouped_input #> → na_keys power_inner_join(   male_penguins[c(\"species\", \"island\")],   female_penguins[c(\"species\", \"island\")] ) #> Joining, by = c(\"species\", \"island\") #> # A tibble: 3 × 2 #>   species island #>   <chr>   <chr>  #> 1 Gentoo  Biscoe #> 2 Gentoo  Biscoe #> 3 Adelie  Dream check_specs(implicit_keys = \"ignore\", duplicate_keys_right = \"abort\") #> # powerjoin check specifications #> → implicit_keys #> → column_conflict #> → duplicate_keys_left #> x duplicate_keys_right #> → unmatched_keys_left #> → unmatched_keys_right #> → missing_key_combination_left #> → missing_key_combination_right #> → inconsistent_factor_levels #> → inconsistent_type #> → grouped_input #> → na_keys power_inner_join(   male_penguins[c(\"species\", \"island\")],   female_penguins[c(\"species\", \"island\")],   check = check_specs(implicit_keys = \"ignore\", duplicate_keys_right = \"abort\") ) #> Error: Keys in the right table have duplicates: #> # A tibble: 1 × 2 #>   species island #>   <chr>   <chr>  #> 1 Gentoo  Biscoe dev_specs <- check_specs(   column_conflict = \"abort\",   inconsistent_factor_levels = \"inform\",   inconsistent_type = \"inform\" )  prod_specs <- check_specs(   column_conflict = \"abort\",   implicit_keys = \"abort\" ) power_inner_join(   male_penguins,   female_penguins,   by = c(\"species\", \"island\"),   check = dev_specs ) #> Error: The following columns are conflicted and their conflicts are not handled:  #> 'name', 'flipper_length_mm', 'body_mass_g'"},{"path":"/index.html","id":"handle-column-conflict","dir":"","previous_headings":"","what":"Handle column conflict","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"saw fail encountering column conflict, show handle . resolve conflicts identically named join columns, set conflict argument 2 argument function (formula) take arguments 2 conflicting joined columns join. Coalescing common use case provide functions coalesce_xy() coalesce_yx() ease task (wrapped around dplyr::coalesce()). Note function operating vectors default, rowwise, however can make work rowwise using rw lhs formula. need finer control, conflict can also named list functions, formulas special values, applied relevant pair conflicted columns.","code":"df1 <- tibble(id = 1:3, value = c(10, NA, 30)) df2 <- tibble(id = 2:4, value = c(22, 32, 42))  power_left_join(df1, df2, by = \"id\", conflict = `+`) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    NA #> 2     2    NA #> 3     3    62 power_left_join(df1, df2, by = \"id\", conflict = coalesce_xy) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    30  power_left_join(df1, df2, by = \"id\", conflict = coalesce_yx) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    32 power_left_join(df1, df2, by = \"id\", conflict = ~ sum(.x, .y, na.rm = TRUE)) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    94 #> 2     2    94 #> 3     3    94  power_left_join(df1, df2, by = \"id\", conflict = rw ~ sum(.x, .y, na.rm = TRUE)) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    62"},{"path":"/index.html","id":"preprocess-inputs","dir":"","previous_headings":"","what":"Preprocess inputs","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"Traditionally key columns need repeated preprocessing inputs join, annoyance opportunity mistakes. {powerjoin} can : semi joins, just omit arguments select_keys_and(): also aggregate keys join, without need group_by()/ungroup() gymnastics : pack_along_keys() packs given columns, non key columns default, data frame column named name argument, ’s useful namespace data avoid conflicts , variants tidyverse functions : nest_by_keys() nests given columns, default, name given single list column data frames created complete_keys() expands key columns, combinations present, filling rest new rows NAs. Absent factor levels expanded well. functions modify data add attribute processed join function later , function used top .","code":"power_inner_join(   male_penguins %>% select_keys_and(name),   female_penguins %>% select_keys_and(female_name = name),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 4 #>   species island name    female_name #>   <chr>   <chr>  <chr>   <chr>       #> 1 Gentoo  Biscoe Giordan Alonda      #> 2 Gentoo  Biscoe Giordan Mishayla    #> 3 Adelie  Dream  Reiner  Ola power_inner_join(   male_penguins,   female_penguins %>% select_keys_and(),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 5 #>   name    species island flipper_length_mm body_mass_g #>   <chr>   <chr>   <chr>              <int>       <int> #> 1 Giordan Gentoo  Biscoe               222        5250 #> 2 Giordan Gentoo  Biscoe               222        5250 #> 3 Reiner  Adelie  Dream                185        3650 power_left_join(   male_penguins %>% summarize_by_keys(male_weight = mean(body_mass_g)),   female_penguins %>% summarize_by_keys(female_weight = mean(body_mass_g)),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 4 #>   species island    male_weight female_weight #>   <chr>   <chr>           <dbl>         <dbl> #> 1 Adelie  Dream            3650          3600 #> 2 Adelie  Torgersen        3900            NA #> 3 Gentoo  Biscoe           5250          4625 power_left_join(   male_penguins %>% pack_along_keys(name = \"m\"),   female_penguins %>% pack_along_keys(name = \"f\"),   by = c(\"species\", \"island\") ) #> # A tibble: 4 × 4 #>   species island    m$name $flipper_length… $body_mass_g f$name $flipper_length… #>   <chr>   <chr>     <chr>             <int>        <int> <chr>             <dbl> #> 1 Gentoo  Biscoe    Giord…              222         5250 Alonda              211 #> 2 Gentoo  Biscoe    Giord…              222         5250 Misha…              215 #> 3 Adelie  Torgersen Lynden              190         3900 <NA>                 NA #> 4 Adelie  Dream     Reiner              185         3650 Ola                 190"},{"path":"/index.html","id":"fuzzy-joins","dir":"","previous_headings":"","what":"Fuzzy joins","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"fuzzy joins use formulas argument, formula use, .x .y describe left right tables. flexible can costly since cartesian product computed. might also mix fuzzy joins regular joins : Finally might want create column value used comparison, case use <- formula (several times needed)`:","code":"power_inner_join(     male_penguins %>% select_keys_and(male_name = name),     female_penguins %>% select_keys_and(female_name = name),     by = c(~.x$flipper_length_mm < .y$flipper_length_mm, ~.x$body_mass_g > .y$body_mass_g) ) #> # A tibble: 1 × 6 #>   flipper_length_mm.x body_mass_g.x male_name flipper_length_mm.y body_mass_g.y #>                 <int>         <int> <chr>                   <dbl>         <int> #> 1                 185          3650 Reiner                    190          3600 #> # … with 1 more variable: female_name <chr> power_inner_join(     male_penguins %>% select_keys_and(male_name = name),     female_penguins %>% select_keys_and(female_name = name),     by = c(\"island\", ~.x$flipper_length_mm > .y$flipper_length_mm) ) #> # A tibble: 2 × 5 #>   island flipper_length_mm.x male_name flipper_length_mm.y female_name #>   <chr>                <int> <chr>                   <dbl> <chr>       #> 1 Biscoe                 222 Giordan                   211 Alonda      #> 2 Biscoe                 222 Giordan                   215 Mishayla power_inner_join(     male_penguins %>% select_keys_and(male_name = name),     female_penguins %>% select_keys_and(female_name = name),     by = ~ (mass_ratio <- .y$body_mass_g / .x$body_mass_g) > 1.2 ) #> # A tibble: 3 × 5 #>   body_mass_g.x male_name body_mass_g.y female_name mass_ratio #>           <int> <chr>             <int> <chr>            <dbl> #> 1          3900 Lynden             4750 Mishayla          1.22 #> 2          3650 Reiner             4500 Alonda            1.23 #> 3          3650 Reiner             4750 Mishayla          1.30"},{"path":"/index.html","id":"fill-unmatched-values","dir":"","previous_headings":"","what":"Fill unmatched values","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"fill argument used specify fill unmatched values , note missing values resulting matches replaced.","code":"df1 <- tibble(id = 1:3) df2 <- tibble(id = 1:2, value2 = c(2, NA), value3 = c(NA, 3))  power_left_join(df1, df2, by = \"id\", fill = 0) #> # A tibble: 3 × 3 #>      id value2 value3 #>   <int>  <dbl>  <dbl> #> 1     1      2     NA #> 2     2     NA      3 #> 3     3      0      0  power_left_join(df1, df2, by = \"id\", fill = list(value2 = 0)) #> # A tibble: 3 × 3 #>      id value2 value3 #>   <int>  <dbl>  <dbl> #> 1     1      2     NA #> 2     2     NA      3 #> 3     3      0     NA"},{"path":"/index.html","id":"join-recursively","dir":"","previous_headings":"","what":"Join recursively","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"x y arguments accept lists data frames one can :","code":"df1 <- tibble(id = 1, a = \"foo\") df2 <- tibble(id = 1, b = \"bar\") df3 <- tibble(id = 1, c = \"baz\")  power_left_join(list(df1, df2, df3), by = \"id\") #> # A tibble: 1 × 4 #>      id a     b     c     #>   <dbl> <chr> <chr> <chr> #> 1     1 foo   bar   baz  power_left_join(df1, list(df2, df3), by = \"id\") #> # A tibble: 1 × 4 #>      id a     b     c     #>   <dbl> <chr> <chr> <chr> #> 1     1 foo   bar   baz"},{"path":"/index.html","id":"enhanced-keep-argument","dir":"","previous_headings":"","what":"Enhanced keep argument","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"default, {dplyr}, key columns merged given names left table. case fuzzy join columns participate fuzzy join kept sides. provide additional values \"left\", \"right\", \"\" \"none\" choose keys keep drop.","code":""},{"path":"/index.html","id":"notes","dir":"","previous_headings":"","what":"Notes","title":"Extensions of dplyr and fuzzyjoin Join Functions","text":"package supersedes {safejoin} package unfortunate homonym CRAN suboptimal interface implementation. Hadley Wickham, Romain François David Robinson credited work {dplyr} {fuzzyjoin} since package contains code copied packages.","code":""},{"path":"/reference/check_specs.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a checklist for power joins — check_specs","title":"Build a checklist for power joins — check_specs","text":"Build checklist power joins","code":""},{"path":"/reference/check_specs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a checklist for power joins — check_specs","text":"","code":"check_specs(   implicit_keys = c(\"inform\", \"ignore\", \"warn\", \"abort\"),   column_conflict = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   duplicate_keys_left = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   duplicate_keys_right = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   unmatched_keys_left = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   unmatched_keys_right = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   missing_key_combination_left = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   missing_key_combination_right = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   inconsistent_factor_levels = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   inconsistent_type = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   grouped_input = c(\"ignore\", \"inform\", \"warn\", \"abort\"),   na_keys = c(\"ignore\", \"inform\", \"warn\", \"abort\") )"},{"path":"/reference/check_specs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a checklist for power joins — check_specs","text":"implicit_keys keys given explicitly argument column_conflict join creates column conflict handled conflict argument duplicate_keys_left find duplicate sets keys left table duplicate_keys_right find duplicate sets keys right table unmatched_keys_left find unmatched sets keys left table unmatched_keys_right find unmatched sets keys right table missing_key_combination_left left table contain key combinations missing_key_combination_right right table contain key combinations inconsistent_factor_levels key columns sides inconsistent factor levels inconsistent_type joined keys different type grouped_input one tables grouped na_keys keys contain missing values","code":""},{"path":"/reference/check_specs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a checklist for power joins — check_specs","text":"character vector class \"powerjoin_check\"","code":""},{"path":"/reference/check_specs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a checklist for power joins — check_specs","text":"","code":"check_specs(   implicit_keys = \"ignore\",   grouped_input = \"inform\",   column_conflict = \"abort\",   na_keys =\"warn\") #> # powerjoin check specifications #> → implicit_keys #> ✖ column_conflict #> → duplicate_keys_left #> → duplicate_keys_right #> → unmatched_keys_left #> → unmatched_keys_right #> → missing_key_combination_left #> → missing_key_combination_right #> → inconsistent_factor_levels #> → inconsistent_type #> ℹ grouped_input #> ! na_keys"},{"path":"/reference/coalesce_xy.html","id":null,"dir":"Reference","previous_headings":"","what":"Coalesce helpers — coalesce_xy","title":"Coalesce helpers — coalesce_xy","text":"wrappers around dplyr::coalesce, designed convenient use conflict argument powerjoin's join functions. coalesce_xy() just like dplyr::coalesce (except takes 2 arguments), coalesce_yx() looks first y x y missing.","code":""},{"path":"/reference/coalesce_xy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coalesce helpers — coalesce_xy","text":"","code":"coalesce_xy(x, y)  coalesce_yx(x, y)"},{"path":"/reference/coalesce_xy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coalesce helpers — coalesce_xy","text":"x vector y vector","code":""},{"path":"/reference/coalesce_xy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coalesce helpers — coalesce_xy","text":"vector","code":""},{"path":"/reference/coalesce_xy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coalesce helpers — coalesce_xy","text":"","code":"coalesce_xy(c(NA, 2, 3), c(11, 12, NA)) #> [1] 11  2  3 coalesce_yx(c(NA, 2, 3), c(11, 12, NA)) #> [1] 11 12  3"},{"path":"/reference/extended-equality.html","id":null,"dir":"Reference","previous_headings":"","what":"Extended equality operators — extended-equality","title":"Extended equality operators — extended-equality","text":"%==% bone operator, works like == NA %==% 1 FALSE NA %==% NA TRUE. %.% vectorized %%, can seen rowwise %% applied data frame columns. convenient helpers fuzzy joins.","code":""},{"path":"/reference/extended-equality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extended equality operators — extended-equality","text":"","code":"x %==% y  x %in.% y"},{"path":"/reference/extended-equality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extended equality operators — extended-equality","text":"x vector y vector %==%, list vectors %.%","code":""},{"path":"/reference/extended-equality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extended equality operators — extended-equality","text":"","code":"df1 <- data.frame(key = c(\"b\", \"z\")) df2 <- data.frame(key1 = c(\"a\", \"b\", \"c\"), key2 = c(\"x\", \"y\", \"z\"), val = 1:3) power_left_join(df1, df2, ~ .x$key %in.% list(.y$key1, .y$key2)) #>   key key1 key2 val #> 1   b    b    y   2 #> 2   z    c    z   3  df3 <- data.frame(key1 = c(\"a\", NA)) df4 <- data.frame(key2 = c(\"a\", \"b\", NA), val = 1:3)  # note the difference power_inner_join(df3, df4, by = ~ .x$key1 == .y$key2) #>   key1 key2 val #> 1    a    a   1 power_inner_join(df3, df4, by = ~ .x$key1 %==% .y$key2) #>   key1 key2 val #> 1    a    a   1 #> 2 <NA> <NA>   3  # typically we would only use the conditions above as part of more complex conditions. # In this precise case they are equivalent to these equi joins power_inner_join(df3, df4, by = c(key1 = \"key2\")) #>   key1 val #> 1    a   1 #> 2 <NA>   3 power_inner_join(df3, df4, by = c(key1 = \"key2\"), na_matches = \"never\") #>   key1 val #> 1    a   1"},{"path":"/reference/full_diagnostic.html","id":null,"dir":"Reference","previous_headings":"","what":"Inform on all potential issues — full_diagnostic","title":"Inform on all potential issues — full_diagnostic","text":"output check_specs() arguments set \"inform\", useful complete join diagnostic.","code":""},{"path":"/reference/full_diagnostic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inform on all potential issues — full_diagnostic","text":"","code":"full_diagnostic"},{"path":"/reference/full_diagnostic.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Inform on all potential issues — full_diagnostic","text":"object class powerjoin_check length 12.","code":""},{"path":"/reference/paste_xy.html","id":null,"dir":"Reference","previous_headings":"","what":"Paste helpers — paste_xy","title":"Paste helpers — paste_xy","text":"similar paste() default ignore NA empty strings (\"\"). found conflicting column return value column without using separator. columns values return empty string.","code":""},{"path":"/reference/paste_xy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Paste helpers — paste_xy","text":"","code":"paste_xy(x, y, sep = \" \", na = NULL, ignore_empty = TRUE)  paste_yx(x, y, sep = \" \", na = NULL, ignore_empty = TRUE)"},{"path":"/reference/paste_xy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Paste helpers — paste_xy","text":"x vector y vector sep separator na treat NAs, ignored default, NA result NA, just stringr::str_c, \"NA\" NAs coerced character just paste(). string can used ignore_empty Whether ignore empty strings, avoid trailing leading separators","code":""},{"path":"/reference/paste_xy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Paste helpers — paste_xy","text":"character vector","code":""},{"path":"/reference/paste_xy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Paste helpers — paste_xy","text":"","code":"paste_xy(letters[1:3], c(\"d\", NA, \"\")) #> [1] \"a d\" \"b\"   \"c\"   paste_yx(letters[1:3], c(\"d\", NA, \"\")) #> [1] \"d a\" \"b\"   \"c\"   paste_xy(letters[1:3], c(\"d\", NA, \"\"), na = NA, ignore_empty = FALSE) #> [1] \"a d\" NA    \"c \"  paste_xy(letters[1:3], c(\"d\", NA, \"\"), na = \"NA\", ignore_empty = FALSE) #> [1] \"a d\"  \"b NA\" \"c\""},{"path":"/reference/power_left_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Power joins — power_left_join","title":"Power joins — power_left_join","text":"Power joins","code":""},{"path":"/reference/power_left_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power joins — power_left_join","text":"","code":"power_left_join(   x,   y = NULL,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   keep = NULL,   na_matches = c(\"na\", \"never\"),   check = check_specs(),   conflict = NULL,   fill = NULL )  power_right_join(   x,   y = NULL,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   keep = NULL,   na_matches = c(\"na\", \"never\"),   check = check_specs(),   conflict = NULL,   fill = NULL )  power_inner_join(   x,   y = NULL,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   keep = NULL,   na_matches = c(\"na\", \"never\"),   check = check_specs(),   conflict = NULL,   fill = NULL )  power_full_join(   x,   y = NULL,   by = NULL,   copy = FALSE,   suffix = c(\".x\", \".y\"),   keep = NULL,   na_matches = c(\"na\", \"never\"),   check = check_specs(),   conflict = NULL,   fill = NULL )"},{"path":"/reference/power_left_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power joins — power_left_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. dplyr, extended user can supply formula list character formulas. Formulas used fuzzy joins, see dedicated section . copy Ignored moment powerjoin support databases suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep boolean compatibility dplyr, value among \"left\", \"right\", \"\", \"none\" \"default\". See dedicated section . na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). check list created check_specs() conflict function, formula, special value amongst \"patch\", named list items. LHS formula rw rhs applied rowwise. Note columns subsetted [ list columns .x .y refer length 1 lists might sometimes need .x[[1]] .y[[1]]. fill Values used replace missing values originating unmatched keys, named list items.","code":""},{"path":"/reference/power_left_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power joins — power_left_join","text":"data frame","code":""},{"path":"/reference/power_left_join.html","id":"keep-argument-values","dir":"Reference","previous_headings":"","what":"keep argument values","title":"Power joins — power_left_join","text":"NULL (default) : merge keys name left table's keys, keep columns used fuzzy joins tables left : keep key columns left table right: keep key columns right table TRUE: keep key columns tables, adding suffix relevant none : drop key columns output FALSE : merge keys name left table's keys, maps none fuzzy joins","code":""},{"path":"/reference/power_left_join.html","id":"fuzzy-joins","dir":"Reference","previous_headings":"","what":"fuzzy joins","title":"Power joins — power_left_join","text":"specify fuzzy matching conditions use formulas refer columns left side data frame using .x right side data frame using .y, instance = ~ .x$col1 > .y$col2. can specify several condition even mix equi condition fuzzy condition, instance = c(col1 = \"col2\", ~ .x$col3 > .y$col4) fuzzy match strings can leverage functions stringr package since vectorized main arguments, instance match observations col1 contains col1 can attach stringr =  ~ str_detect(.x$col1, fixed(.y$col2)). Another useful function stringdist stringdist package match strings close enough, instance = ~ stringdist::stringdist(.x$,.y$) < 2 can also define new column computed fuzzy matching, using arrow assignment operator, instance : = ~ .x$col1 > (mysum <- .y$col2 + .y$col3) condition evaluates NA observation dismissed. makes = c(= \"b\") slightly different = ~ .x$== .y$b na_matches \"na\" (default). able match NA NA fuzzy matching condition can use %==% operator (bone operator), defined package.","code":""},{"path":"/reference/power_left_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power joins — power_left_join","text":"","code":"# See README for a more verbose version library(tibble) male_penguins <- tribble(   ~name,    ~species,     ~island, ~flipper_length_mm, ~body_mass_g,   \"Giordan\",    \"Gentoo\",    \"Biscoe\",               222L,        5250L,   \"Lynden\",    \"Adelie\", \"Torgersen\",               190L,        3900L,   \"Reiner\",    \"Adelie\",     \"Dream\",               185L,        3650L )  female_penguins <- tribble(   ~name,    ~species,  ~island, ~flipper_length_mm, ~body_mass_g,   \"Alonda\",    \"Gentoo\", \"Biscoe\",               211,        4500L,   \"Ola\",    \"Adelie\",  \"Dream\",               190,        3600L,   \"Mishayla\",    \"Gentoo\", \"Biscoe\",               215,        4750L, )  # apply different checks power_inner_join(   male_penguins[c(\"species\", \"island\")],   female_penguins[c(\"species\", \"island\")],   check = check_specs(implicit_keys = \"ignore\", duplicate_keys_right = \"inform\") ) #> Keys in the right table have duplicates: #> # A tibble: 1 × 2 #>   species island #>   <chr>   <chr>  #> 1 Gentoo  Biscoe #> # A tibble: 3 × 2 #>   species island #>   <chr>   <chr>  #> 1 Gentoo  Biscoe #> 2 Gentoo  Biscoe #> 3 Adelie  Dream   df1 <- tibble(id = 1:3, value = c(10, NA, 30)) df2 <- tibble(id = 2:4, value = c(22, 32, 42))  # handle conflicted columns when joining power_left_join(df1, df2, by = \"id\", conflict = `+`) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    NA #> 2     2    NA #> 3     3    62  # the most frequent use case is to coalesce power_left_join(df1, df2, by = \"id\", conflict = coalesce_xy) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    30 power_left_join(df1, df2, by = \"id\", conflict = coalesce_yx) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    32  # the conflict function is applied colwise by default! power_left_join(df1, df2, by = \"id\", conflict = ~ sum(.x, .y, na.rm = TRUE)) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    94 #> 2     2    94 #> 3     3    94  # apply conflict function rowwise power_left_join(df1, df2, by = \"id\", conflict = rw ~ sum(.x, .y, na.rm = TRUE)) #> # A tibble: 3 × 2 #>      id value #>   <int> <dbl> #> 1     1    10 #> 2     2    22 #> 3     3    62  # subset columns without repeating keys power_inner_join(   male_penguins %>% select_keys_and(name),   female_penguins %>% select_keys_and(female_name = name),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 4 #>   species island name    female_name #>   <chr>   <chr>  <chr>   <chr>       #> 1 Gentoo  Biscoe Giordan Alonda      #> 2 Gentoo  Biscoe Giordan Mishayla    #> 3 Adelie  Dream  Reiner  Ola          # semi join power_inner_join(   male_penguins,   female_penguins %>% select_keys_and(),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 5 #>   name    species island flipper_length_mm body_mass_g #>   <chr>   <chr>   <chr>              <int>       <int> #> 1 Giordan Gentoo  Biscoe               222        5250 #> 2 Giordan Gentoo  Biscoe               222        5250 #> 3 Reiner  Adelie  Dream                185        3650  # agregate without repeating keys power_left_join(   male_penguins %>% summarize_by_keys(male_weight = mean(body_mass_g)),   female_penguins %>% summarize_by_keys(female_weight = mean(body_mass_g)),   by = c(\"species\", \"island\") ) #> # A tibble: 3 × 4 #>   species island    male_weight female_weight #>   <chr>   <chr>           <dbl>         <dbl> #> 1 Adelie  Dream            3650          3600 #> 2 Adelie  Torgersen        3900            NA #> 3 Gentoo  Biscoe           5250          4625  # pack auxiliary colums without repeating keys power_left_join(   male_penguins %>% pack_along_keys(name = \"m\"),   female_penguins %>% pack_along_keys(name = \"f\"),   by = c(\"species\", \"island\") ) #> # A tibble: 4 × 4 #>   species island    m$name  $flipper_length_mm $body_mass_g f$name   #>   <chr>   <chr>     <chr>                <int>        <int> <chr>    #> 1 Gentoo  Biscoe    Giordan                222         5250 Alonda   #> 2 Gentoo  Biscoe    Giordan                222         5250 Mishayla #> 3 Adelie  Torgersen Lynden                 190         3900 NA       #> 4 Adelie  Dream     Reiner                 185         3650 Ola      #> # ℹ 2 more variables: f$flipper_length_mm <dbl>, $body_mass_g <int>  # fuzzy join power_inner_join(   male_penguins %>% select_keys_and(male_name = name),   female_penguins %>% select_keys_and(female_name = name),   by = c(~.x$flipper_length_mm < .y$flipper_length_mm, ~.x$body_mass_g > .y$body_mass_g) ) #> # A tibble: 1 × 6 #>   flipper_length_mm.x body_mass_g.x male_name flipper_length_mm.y body_mass_g.y #>                 <int>         <int> <chr>                   <dbl>         <int> #> 1                 185          3650 Reiner                    190          3600 #> # ℹ 1 more variable: female_name <chr>  # fuzzy + equi join power_inner_join(   male_penguins %>% select_keys_and(male_name = name),   female_penguins %>% select_keys_and(female_name = name),   by = c(\"island\", ~.x$flipper_length_mm > .y$flipper_length_mm) ) #> # A tibble: 2 × 5 #>   island flipper_length_mm.x male_name flipper_length_mm.y female_name #>   <chr>                <int> <chr>                   <dbl> <chr>       #> 1 Biscoe                 222 Giordan                   211 Alonda      #> 2 Biscoe                 222 Giordan                   215 Mishayla     # define new column without repeating computation power_inner_join(   male_penguins %>% select_keys_and(male_name = name),   female_penguins %>% select_keys_and(female_name = name),   by = ~ (mass_ratio <- .y$body_mass_g / .x$body_mass_g) > 1.2 ) #> # A tibble: 3 × 5 #>   body_mass_g.x male_name body_mass_g.y female_name mass_ratio #>           <int> <chr>             <int> <chr>            <dbl> #> 1          3900 Lynden             4750 Mishayla          1.22 #> 2          3650 Reiner             4500 Alonda            1.23 #> 3          3650 Reiner             4750 Mishayla          1.30 power_inner_join(   male_penguins %>% select_keys_and(male_name = name),   female_penguins %>% select_keys_and(female_name = name),   by = ~ (mass_ratio <- .y$body_mass_g / .x$body_mass_g) > 1.2,   keep = \"none\" ) #> # A tibble: 3 × 3 #>   male_name female_name mass_ratio #>   <chr>     <chr>            <dbl> #> 1 Lynden    Mishayla          1.22 #> 2 Reiner    Alonda            1.23 #> 3 Reiner    Mishayla          1.30  # fill unmatched values df1 <- tibble(id = 1:3) df2 <- tibble(id = 1:2, value2 = c(2, NA), value3 = c(NA, 3)) power_left_join(df1, df2, by = \"id\", fill = 0) #> # A tibble: 3 × 3 #>      id value2 value3 #>   <int>  <dbl>  <dbl> #> 1     1      2     NA #> 2     2     NA      3 #> 3     3      0      0 power_left_join(df1, df2, by = \"id\", fill = list(value2 = 0)) #> # A tibble: 3 × 3 #>      id value2 value3 #>   <int>  <dbl>  <dbl> #> 1     1      2     NA #> 2     2     NA      3 #> 3     3      0     NA  # join recursively df1 <- tibble(id = 1, a = \"foo\") df2 <- tibble(id = 1, b = \"bar\") df3 <- tibble(id = 1, c = \"baz\") power_left_join(list(df1, df2, df3), by = \"id\") #> # A tibble: 1 × 4 #>      id a     b     c     #>   <dbl> <chr> <chr> <chr> #> 1     1 foo   bar   baz   power_left_join(df1, list(df2, df3), by = \"id\") #> # A tibble: 1 × 4 #>      id a     b     c     #>   <dbl> <chr> <chr> <chr> #> 1     1 foo   bar   baz"},{"path":"/reference/powerjoin-package.html","id":null,"dir":"Reference","previous_headings":"","what":"powerjoin: Extensions of 'dplyr' and 'fuzzyjoin' Join Functions — powerjoin-package","title":"powerjoin: Extensions of 'dplyr' and 'fuzzyjoin' Join Functions — powerjoin-package","text":"extend 'dplyr' 'fuzzyjoin' join functions features preprocess data, apply various data checks, deal conflicting columns.","code":""},{"path":[]},{"path":"/reference/powerjoin-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"powerjoin: Extensions of 'dplyr' and 'fuzzyjoin' Join Functions — powerjoin-package","text":"Maintainer: Antoine Fabri antoine.fabri@gmail.com contributors: Hadley Wickham hadley@rstudio.com (ORCID) (aut/cre dplyr) [contributor] Romain François (ORCID) (aut dplyr) [contributor] David Robinson admiral.david@gmail.com (aut fuzzyjoin) [contributor] RStudio (cph/fnd dplyr) [copyright holder, funder]","code":""},{"path":"/reference/preprocess_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Preprocess powerjoin inputs — preprocess_inputs","title":"Preprocess powerjoin inputs — preprocess_inputs","text":"functions named tidyverse functions select, summarize, nest, pack, pivot_wider pivot_longer designed avoid repetition key columns preprocessing data join. used x y arguments powerjoin join functions. transformation applied top .","code":""},{"path":"/reference/preprocess_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preprocess powerjoin inputs — preprocess_inputs","text":"","code":"select_keys_and(.data, ...)  summarize_by_keys(.data, ...)  nest_by_keys(.data, ..., name = NULL)  pack_along_keys(.data, ..., name)  complete_keys(.data)"},{"path":"/reference/preprocess_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preprocess powerjoin inputs — preprocess_inputs","text":".data data frame pivot. ... Additional arguments passed methods. name Name created column","code":""},{"path":"/reference/preprocess_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preprocess powerjoin inputs — preprocess_inputs","text":"data frame identical .data \"powerjoin_preprocess\" attribute handled join functions","code":""},{"path":"/reference/preprocess_inputs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preprocess powerjoin inputs — preprocess_inputs","text":"Unlike tidyverse counterparts just add attribute input reshape . join function preprocesses inputs using attributes keys.","code":""},{"path":"/reference/preprocess_inputs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Preprocess powerjoin inputs — preprocess_inputs","text":"","code":"# in practice you'll mostly use those in join function calls directly x <- select_keys_and(head(iris, 2), Sepal.Width) # all it does is add an attribute that will be processed by the join function attr(x, \"powerjoin_preprocess\") #> $type #> [1] \"select_keys_and\" #>  #> $args #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^Sepal.Width #> env:  0x55d1d896b090 #>  #>  # see `?power_left_join` or README for practical examples"},{"path":"/news/index.html","id":"powerjoin-010","dir":"Changelog","previous_headings":"","what":"powerjoin 0.1.0","title":"powerjoin 0.1.0","text":"CRAN release: 2022-11-03 join functions fail provided check argument built check_specs() New functions paste_xy() paste_yx() conflict columns pasting, ignoring NAs empty strings default using rw ~ ... conflict argument better documented class dates lost anymore using rw ~ ... conflict argument Obsolete imports removed Rebuilding documentation solves issues got package kicked CRAN","code":""}]
